/*
 * /*
 * Informational Notice:
 * This software was developed under contract funded by the National Library of Medicine, which is part of the National Institutes of Health, 
 * an agency of the Department of Health and Human Services, United States Government.
 *
 * The license of this software is an open-source BSD license.  It allows use in both commercial and non-commercial products.
 *
 * The license does not supersede any applicable United States law.
 *
 * The license does not indemnify you from any claims brought by third parties whose proprietary rights may be infringed by your usage of this software.
 *
 * Government usage rights for this software are established by Federal law, which includes, but may not be limited to, Federal Acquisition Regulation 
 * (FAR) 48 C.F.R. Part52.227-14, Rights in Dataï¿½General.
 * The license for this software is intended to be expansive, rather than restrictive, in encouraging the use of this software in both commercial and 
 * non-commercial products.
 *
 * LICENSE:
 *
 * Government Usage Rights Notice:  The U.S. Government retains unlimited, royalty-free usage rights to this software, but not ownership,
 * as provided by Federal law.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * -	Redistributions of source code must retain the above Government Usage Rights Notice, this list of conditions and the following disclaimer.
 *
 * -	Redistributions in binary form must reproduce the above Government Usage Rights Notice, this list of conditions and the following disclaimer 
 * in the documentation and/or other materials provided with the distribution.
 *
 * -	The names,trademarks, and service marks of the National Library of Medicine, the National Cancer Institute, the National Institutes 
 * of Health,  and the names of any of the software developers shall not be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE U.S. GOVERNMENT AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE U.S. GOVERNMENT
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package gov.nih.nlm.lpf.emails.nlpproc.infer;

import gov.nih.nlm.lpf.emails.nlpproc.TextMessageProcessor;

import gov.nih.nlm.lpf.emails.nlpproc.structure.ProcessedResults;
import gov.nih.nlm.lpf.emails.nlpproc.structure.PersonAttributes;
import   gov.nih.nlm.lpf.emails.nlpproc.structure.SubjectEntity;
import   gov.nih.nlm.lpf.emails.nlpproc.structure.InferredPerson;
import   gov.nih.nlm.lpf.emails.nlpproc.structure.LPFEntity;

import   gov.nih.nlm.lpf.emails.nlpproc.structure.PredicateModel;
import   gov.nih.nlm.lpf.emails.nlpproc.structure.ClausalAssertion;

import  gov.nih.nlm.lpf.emails.nlpproc.structure.AnaphoraInfo;
import  gov.nih.nlm.lpf.emails.nlpproc.structure.CorefInfo;

import   gov.nih.nlm.lpf.emails.nlpproc.nlp.Clause;
import gov.nih.nlm.lpf.emails.nlpproc.nlp.TextAnnotation;
import   gov.nih.nlm.lpf.emails.nlpproc.nlp.TextAnchor;
import   gov.nih.nlm.lpf.emails.nlpproc.nlp.VerbAnchor;

import   gov.nih.nlm.lpf.emails.nlpproc.ner.LPFVerbs;

import  gov.nih.nlm.lpf.emails.nlpproc.analysis.MessageAnalyzer;
import  gov.nih.nlm.lpf.emails.nlpproc.analysis.resolve.NameResolver;
import  gov.nih.nlm.lpf.emails.nlpproc.analysis.resolve.PersonResolver;

import  gov.nih.nlm.lpf.emails.rule.PersonRanker;



import gate.Document;

import gov.nih.nlm.lpf.emails.nlpproc.ner.NERConstants;
import static gov.nih.nlm.lpf.emails.nlpproc.ner.NERConstants.CLAUSAL_SUBJECT;
import gov.nih.nlm.lpf.emails.nlpproc.ner.PLLexicon;

import java.util.ArrayList;
import java.util.TreeMap;
import java.util.HashMap;
import java.util.Collection;
import java.util.Iterator;
import java.util.Collections;

import org.apache.log4j.Logger;

/**
 *
 * @author 
 */
public class PLInferenceEngine  implements TextMessageProcessor
{
    private Logger log = Logger.getLogger(PLInferenceEngine.class);

    // input data
    protected Document  lpfMessage;
    protected ProcessedResults inputResults;
    

    // input data
    // Annotation generated by GATE
    ArrayList <TextAnnotation> personAnnots;
    ArrayList <TextAnnotation> locationAnnots;
     ArrayList <TextAnnotation>  attributeAnnots;  // List of annotated attributes of a persons (name, age etc.) from GATE

    TreeMap<TextAnchor, AnaphoraInfo> anaphoraMap;
    TreeMap<TextAnchor, CorefInfo>  corefMap;
    TreeMap<TextAnchor, SubjectEntity> lpfSubjectMap;    // set of unique lpfSubjects against the matching anchor
    
     ArrayList<SubjectEntity> lpfSubjects;
     ArrayList<SubjectEntity> allSubjects;                                     // includes the NullSubject
     SubjectEntity NullSubject ;                                                       // Clausal information with no associated lpfSubject
      int numMsgAssertions;                                                                  // Total number of Assertions in the message                                      
    
    /*** results generated by this module **/
     protected ProcessedResults processedResults;           // to be passed on to the pipeline
    ArrayList <SubjectEntity> reporterSubjects = new ArrayList();      // not to process them again
    /********/
    
   // sub-ordinate objects 
    VerbInterpreter vbInterp;
    VerbInferenceGen vbInfer;
    EntityClassifier entityClassifier;
    
     String  msgText;

    public PLInferenceEngine(Document gateDoc, MessageAnalyzer analyzer) 
    {
        lpfMessage = gateDoc;
        inputResults = analyzer.getProcessedResults();
        processedResults = inputResults;
        
        // retrieveinput processed results needed for drawing inference
        retrieveInputData();
    }  
    protected void retrieveInputData()
    {
        locationAnnots = inputResults.locationList;
        personAnnots = inputResults.personList;
        attributeAnnots = inputResults.attributeList;

        anaphoraMap = inputResults.anaphoraMap;
        corefMap = inputResults.corefMap;
        lpfSubjectMap = inputResults.subjectMap;
        NullSubject  =  inputResults.nullSubject;
        
        msgText = lpfMessage.getContent().toString();
    }
    
    public void  generateInference()
    {
        vbInterp = VerbInterpreter.getInterpreter(inputResults.plLexicon);
        vbInfer= VerbInferenceGen.getInferenceEngine();
        entityClassifier = new EntityClassifier(personAnnots,  attributeAnnots);
        
        // retrieve all lSubjectEntities including the Null subject
        // create a list of all subjects 
        lpfSubjects = new ArrayList();
         Iterator <TextAnchor> it = lpfSubjectMap.keySet().iterator();
         while (it.hasNext())
             lpfSubjects.add(lpfSubjectMap.get(it.next()));         // with a clausal subject 

        allSubjects = new ArrayList(); 
        allSubjects.addAll(lpfSubjects);
        if (NullSubject != null)
            allSubjects.add(NullSubject);
        
         // Build the Simple Predicate or Verb  for the ClausalAssertions for each lpfSubject 
         // (including the NullSubject)
          for (int i = 0; i < allSubjects.size(); i++)
         {
             SubjectEntity lpfSubject = allSubjects.get(i);
             buildPredicateModels(lpfSubject);
         } 
         ArrayList< InferredPerson> candidatePersonList  =  generateInferredPersonList();        
         
         // update the processedResults data
         processedResults.inferredPersonList = candidatePersonList; 
    }
    
 //---------------------------------------------------------------------------------------------------------------------/
    // Analyse all data processed fo far and identify all reported persons and associated
    // information and generate a record for each such person
    //-----------------------------------------------------------------------------------------------------------------/
    public   ArrayList< InferredPerson>  generateInferredPersonList()
    {
        // build the list of all Entities, used as either subjects or objects in a sentence clause
        // later we will classify these entities to find Reported persons
        TreeMap  <TextAnchor, LPFEntity>  lpfEntityMap = buildLPFEntityMap();
        
       // separate the personal attribute data and non-person subjects from building uniquePersonMap
        // Note: This removes the corresponding entries from thr lpfEntityMap
        TreeMap <TextAnchor, PersonAttributes>  personAttributeMap = linkPerson2Attributes(lpfEntityMap);

       //  We may also get  Personal Attributes  from Assertions
        addAttributesFromPersonEntity(lpfEntityMap);
     
        // group entries to unique Entities by resolving the name to match individuals
         TreeMap  <TextAnchor, LPFEntity>  uniqueEntityMap = buildUniqueEntityMap(lpfEntityMap);
         
         numMsgAssertions = getTotalMessageAsserions( uniqueEntityMap.values());
        
         
         // Assign the personCategory (Reporter/ReportedPerson or both) for each PersonEntity
         assignReportingCategory(uniqueEntityMap);
         
         
         // Scan though all unique Entities and pick the ones who are either simply reported persons
         // or both reporter and repoting persons
          ArrayList< InferredPerson>  inferredRPList = 
              createInferredPersonList(uniqueEntityMap, personAttributeMap);
          
          return inferredRPList;
    }
//-----------------------------------------------------------------------------------------------------------/    
    protected int getTotalMessageAsserions( Collection<LPFEntity> uniqueEntities)
    {
         int numAssertions  = 0;
         Iterator <LPFEntity> it  = uniqueEntities.iterator();
         while( it.hasNext()) {
             numAssertions += it.next().getNumAssertions(); }
         return numAssertions;
    }

    //------------------------------------------------------------------------------------------------------------/
    // Check verbs for all lpfSubjects and find the ones with a Status Verb and buils LPFEntity map
    // Ignore other verbs here.
    // Classify entities according to Person, Personal attribute, and non-person nouns
    // For Entities representing a person, set the gender too
    //------------------------------------------------------------------------------------------------------------/
     public TreeMap  <TextAnchor, LPFEntity>  buildLPFEntityMap()
     {

     // Create a list of all noun terms which are subjects or "Person" type objects of all assertion
      // This is the potential Person List
        TreeMap  <TextAnchor, LPFEntity>  lpfEntityMap = new TreeMap();
        for (int i = 0; i < lpfSubjects.size(); i++)
        {
            // First add the subject itself
             SubjectEntity lpfSubject = lpfSubjects.get(i);
             LPFEntity lpfEntity = new LPFEntity(lpfSubject);
             lpfEntityMap.put(lpfSubject.subject,  lpfEntity);
        }
        // add all objectPersons for this entry, including for the null subject
       for (int i = 0; i < allSubjects.size(); i++)
       {
           lpfEntityMap = addPersonsFromObjectList(allSubjects.get(i), lpfEntityMap);
       }
       
       // classify each LPFEntity, and set gender for "PERSON" entities
        Iterator<LPFEntity> iter = lpfEntityMap.values().iterator();
        int nn = 0;
        while (iter.hasNext())
        {
            LPFEntity lpfEntity = iter.next();
            entityClassifier.classifyEntity(lpfEntity);
            if (lpfEntity.entityClass == NERConstants.PERSON_ENTITY)
                setPersonGender(lpfEntity);            // set the gender of the person in an attrbute map
            System.out.println("Entity # " + nn++  +", " +  lpfEntity.subject.getText() +" Entity type: " + lpfEntity.entityClass);
        }
       return lpfEntityMap;
     }
//--------------------------------------------------------------------------------------------------------------------//
     // Build the verb model of each assertion of an LPfSubject instance
     //--------------------------------------------------------------------------------------------------------------------//
     protected void buildPredicateModels(SubjectEntity lpfSubject)
     {
        ArrayList<PredicateModel> predicates = new ArrayList();
        for (int i = 0; i < lpfSubject.assertions.size(); i++)
        {
            ClausalAssertion assertion = lpfSubject.assertions.get(i);        // To Do: all assertions
            VerbAnchor vbr = (VerbAnchor) assertion.verb;

            PredicateModel verbModel = new PredicateModel(vbr, assertion.clause);
            verbModel.verbTense = vbr.getVerbTense();
            int verbCategory = vbInterp. getPLVerbCategory(verbModel, assertion.subject, personAnnots);
            log.info(">> Verb Category for " + vbr.getTextWithXcomp() + " = " + verbCategory);

            verbModel.lpfVerbCategory = verbCategory;
            verbModel.healthStatusCondition = getHealthStatusCategory(verbModel, assertion.clauseGenre);
            predicates.add(verbModel);
        }
        lpfSubject.predicates = predicates;
        return;
     }  

   //------------------------------------------------------------------------------------------------------------/
   // Create a LPFEntity instance for all "Person"  type objects of this LPFSubject
   // which may be a null subject
   // Here we create a unique LPFEntity object for each person object , without resolving
  // if they refer to the same person. That will be resolved later.
  //-----------------------------------------------------------------------------------------------------------/
     protected TreeMap  <TextAnchor, LPFEntity> addPersonsFromObjectList(SubjectEntity lpfSubject, 
         TreeMap  <TextAnchor, LPFEntity>currentEntityMap)
     {
          // get all Persons in the assertions of this lpfSubject   
         int personType = InferredPerson.UNKNOWN_TYPE;
         ArrayList<ClausalAssertion> assertions = lpfSubject.getAssertions();
         for (int i = 0; i <assertions.size(); i++)
         {
             ClausalAssertion assertion = assertions.get(i);
             PredicateModel predicate = lpfSubject.getPredicateModels().get(i);
        
           // create a new LPFEntity or update an existing one for each object in this asserion
             ArrayList<TextAnchor> persons = assertion.persons;
             if (persons == null || persons.isEmpty())
                 continue;
             
             for (int j = 0; j < persons.size(); j++)
             {
                 TextAnchor objectPerson = persons.get(j);
                 LPFEntity lpfEntity = currentEntityMap.get(objectPerson);
                 if (lpfEntity == null)
                 {
                     // create a new entry
                     lpfEntity = new LPFEntity(objectPerson, NERConstants.CLAUSAL_OBJECT);
                     lpfEntity.entityClass = LPFEntity.PERSON_ENTITY;         
                     currentEntityMap.put(objectPerson, lpfEntity);        
                 }
                 // add new information
                 lpfEntity.addObjectAssertion(assertion);
                 lpfEntity.addObjectPredicateModel(predicate);
                 lpfEntity.setReporter(lpfSubject);     // reported by another entity

             }  // all Entitys in an assertion
         }  // all assertions
         return currentEntityMap;
     }

 //------------------------------------------------------------------------------------------------------------------/
 // Analyze the LPFEntities, and link the ones containing a Person's 
 // attribute directly as the "subject" , removing these from from the input lpfEntityMap
 // Otherwose, attributes are also created from corresponding copula objects s in
 // he is 10 years old, 
 //or from the adjective of the subject itself : as in he is an old man,  I found an old man
 //------------------------------------------------------------------------------------------------------------------/
    TreeMap <TextAnchor, PersonAttributes>  linkPerson2Attributes(
                        TreeMap<TextAnchor, LPFEntity> entityMap)
    {
        // Apply Rule 1: Find Personal attribute Entities and link them to the Subject entit
        ArrayList<LPFEntity> attribEntities = new ArrayList();
        Iterator<LPFEntity> iter = entityMap.values().iterator();  
        while (iter.hasNext())
        {
            LPFEntity entity = iter.next();
            if (entity.entityClass == NERConstants.PERSONAL_ATTRIB_ENTITY)
            {
                attribEntities.add(entity);
                iter.remove();     
            }
        }
        if (attribEntities.isEmpty())               // no attrubutes found for any entiry
            return null;
        
        TreeMap <TextAnchor, PersonAttributes> attributeMap = 
              entityClassifier.setPersonalAttribute(msgText, attribEntities, corefMap);
          
         // Now link the LPFPerson to the corresponding attribute
        Iterator<TextAnchor> iter1 = attributeMap.keySet().iterator();  
        while (iter1.hasNext())
        {
            TextAnchor person = iter1.next();
            LPFEntity personEntity = entityMap.get(person);
            if (personEntity == null)
                continue;
            
            PersonAttributes newAttr = attributeMap.get(person);
            PersonAttributes pattr = personEntity.pattr;
            if (pattr == null)
                personEntity.pattr = newAttr;
            else
                personEntity.pattr.mergeAttributes(newAttr);
        }
             
        return attributeMap;
    }   
   
 /*------------------------------------------------------------------------------------------------------------/
// A ttributes are also created from corresponding copula objects as in
 // he is 10 years old, 
 //or from the adjective of the subject itself : as in he is an old man,  I found an old man
 //------------------------------------------------------------------------------------------------------------------*/
    protected   void   addAttributesFromPersonEntity(
                        TreeMap<TextAnchor, LPFEntity> entityMap)
    {
        // Apply Rule 2: Find Personal attributes from copular relations
        Iterator<LPFEntity> iter = entityMap.values().iterator();  
        while (iter.hasNext())          // For each entity
        {
            LPFEntity entity = iter.next();
            if (entity.entityClass != NERConstants.PERSON_ENTITY)
                continue;
            
            // Check if it contains a named attribute as the object. If so add its  Attribute name, value
            HashMap<String, TextAnchor> attributeData = getNamedAttributes(entity);
            if (attributeData != null)
            {
                // create a new PersonAttributes object for this person
                PersonAttributes pattributes = new PersonAttributes(entity.subject);
                Iterator <String> it = attributeData.keySet().iterator();
                while (it.hasNext())
                {
                    String attr = it.next();
                    pattributes.addAttribute(attr, attributeData.get(attr));
                }      
                PersonAttributes pattributes0 = entity.pattr;
                if (pattributes0 == null)
                    entity.pattr = pattributes;
                else
                    entity.pattr.mergeAttributes(pattributes);
            }
            // check if the Clause has an attribute object (Age)
            else
            {
                ArrayList <ClausalAssertion> assertions =  entity.assertions;
                for (int i = 0; i < assertions.size(); i++)
                {
                   HashMap <String, TextAnchor> attributeMap = assertions.get(i).attributes;
                   if (attributeMap == null || attributeMap.isEmpty())
                       continue;
                   Iterator <String> it = attributeMap.keySet().iterator();
                   while (it.hasNext())
                   {
                       String attrName = it.next();
                       TextAnchor attr = attributeMap.get(attrName);
                       if ( entity.pattr == null)
                           entity.pattr = new PersonAttributes(entity.subject);
                       entity.pattr.addAttribute(attrName, attr); 
                   }
                }
           }    // end else
        }   // end while 
        return;
    }

    /****************************************************************************************/     
     protected  HashMap<String, TextAnchor> getNamedAttributes(LPFEntity lpfPerson)
     {
        if (attributeAnnots == null  || attributeAnnots.isEmpty())
            return null;
        
        // get the most relevant assertion as a subject
        ArrayList <PredicateModel>verbModels = lpfPerson.getPredicateModels();
        HashMap <String, TextAnchor> attributeMap = null;
        for (int i = 0; i < verbModels.size(); i++)
        {
            PredicateModel verbModel = verbModels.get(i);
            // check if it referes to personal attributes of a reported person 
            // e.g. He is 10 years old
            attributeMap  = vbInfer.analyzeVerbsForAttributes (verbModel, attributeAnnots);
            if (attributeMap != null)
                break;
        }
        return attributeMap;
     }

/**********************************************************************************************/  
// Merge PersonalAttributes from the two maps to create a combined map
//--------------------------------------------------------------------------------------------------------------------/
    protected     TreeMap <TextAnchor, PersonAttributes> mergeAttributeMaps (
       TreeMap <TextAnchor, PersonAttributes> pmap1, 
       TreeMap <TextAnchor, PersonAttributes> pmap2)
        {
         if (pmap1 == null || pmap1.size() == 0)
             return pmap2;
         else if (pmap2 == null || pmap2.size() == 0)
             return pmap1;

         else   // merge the two sets
         {
             TreeMap <TextAnchor, PersonAttributes> newMap = new TreeMap();
             ArrayList <TextAnchor> plist2 = new ArrayList(pmap2.keySet());
             Iterator <TextAnchor> it = pmap1.keySet().iterator();
             while (it.hasNext())
             {
                 TextAnchor person  = it.next();
                 PersonAttributes pattr1 = pmap1.get(person);
                 if (plist2.contains(person))          // not in both lists
                     newMap.put(person, pattr1);
                 else
                 {
                     PersonAttributes pattr2 = pmap2.get(person);
                     pattr1.mergeAttributes(pattr2);
                     newMap.put(person, pattr1);
                     plist2.remove(person);
                 }
             }  // end while 
             // add the remainig persons, if any, from list 2
              for (int i = 0; i <  plist2.size(); i++)  
              {
                  TextAnchor person = plist2.get(i);
                  newMap.put (person, pmap2.get(person));
              }    
              return newMap;
         }
     }
    
 /**********************************************************************************************/   
  // Set the gender of the Person  in this Entity, if knowm from Coreference map
//------------------------------------------------------------------------------------------------------------------/
    protected void setPersonGender( LPFEntity lpfEntity)
    {
        if (lpfEntity.entityClass != NERConstants.PERSON_ENTITY)
            return;
        TextAnchor person = lpfEntity.subject;
        PersonAttributes pattr = lpfEntity.pattr;
        if (pattr == null)
        {
            pattr = new PersonAttributes(person);
            lpfEntity.pattr =  pattr;
        }

        
        // first check for a referring person
        String gender = "";
        CorefInfo  corefInfo = corefMap.get(person);
        if (corefInfo != null && corefInfo.corefGender.length() > 0)
        {
            if (pattr.gender.length() == 0 || pattr.gender.matches("unknown"))
               gender = corefInfo.corefGender;
            if (gender.equals("unknown"))
                gender = "";
        }
        
        if (gender.length() > 0)
        {
             lpfEntity.pattr.gender = gender;
             return;
        }
            
        //  check if one of the referred persons (anaphoric one) has a gender 
        Iterator<CorefInfo> iter = corefMap.values().iterator();
        while (iter.hasNext())
        {
            corefInfo = iter.next();
            if (corefInfo.corefAnchor.equals(person))
            {
                 gender  = corefInfo.corefGender;
                 if (gender.length() > 0  && !gender.equals("unknown"))
                     break;

                 // check the referrent is a pronoun, get its gender
                 String  referrentText = corefInfo.referringAnnot.text;
                 if (referrentText.matches(NERConstants.FEMALE_PRONOUN))
                 {
                     gender = "female";
                     break;
                 }
                 else if (referrentText.matches(NERConstants.MALE_PRONOUN))
                 {
                     gender = "male";
                     break;
                 }
            }// end if 
        }// end while
                
        lpfEntity.pattr.gender = gender;
        if (pattr.gender.length() == 0)
            pattr.gender = "unknown";
        return;
    }           
     
/**********************************************************************************************/   
  // group entries in the all EntityMap  to unique Entities by resolving the 
  // name to match unique individuals (with coreference resolved)
  //  It  does not contains  PersonAttribute entities, which are removed in linkPerson2Attribute();
    //------------------------------------------------------------------------------------------------------------------/
     protected TreeMap  <TextAnchor, LPFEntity>  buildUniqueEntityMap(
                    TreeMap  <TextAnchor, LPFEntity> lpfEntityMap)
     {
        ArrayList<TextAnchor> lpfEntityList = new ArrayList(lpfEntityMap.keySet());
        
        // perform coreference and anaphoric resolutions
        // key is original entity, value is resolved entity (son, David)
        TreeMap<TextAnchor, TextAnchor>   resolvedEntityMap  =  
                     PersonResolver.resolvePersons(lpfEntityList, personAnnots, corefMap);

        TreeMap <TextAnchor,  LPFEntity>  uniqueEntitys = new TreeMap();
        ArrayList <TextAnchor> entityList = new ArrayList(lpfEntityMap.keySet());
        for (int i = 0; i < entityList.size(); i++)
        {
             TextAnchor personAnchor = entityList.get(i);
             LPFEntity lpfEntity0 = lpfEntityMap.get(personAnchor);

             // combine the assertions with that of the bestmatch subject
             TextAnchor  matchingEntity = resolvedEntityMap.get(personAnchor);
             if (matchingEntity == null)            // not a person
                    matchingEntity = personAnchor;

             // Check if it is a duplicate entry for the same person already in the uniqueEntityMap
             // if so, use the subject already there
              LPFEntity lpfEntity  = getReferredEntity(matchingEntity, uniqueEntitys);
              if (lpfEntity == null)
              {
                  lpfEntity = new LPFEntity(matchingEntity, lpfEntity0.entityType);
                  lpfEntity.entityClass = lpfEntity0.entityClass;
                  lpfEntity.mergeAssertions(lpfEntity0);
                  lpfEntity.mergeAttributes(lpfEntity0);
                  uniqueEntitys.put(matchingEntity, lpfEntity);
                  System.out.println("-- Unique Entity: " + matchingEntity.getText() +
                        ", # of  Assertions: " +   lpfEntity.getNumAssertions());
              }
              else
              {
                  lpfEntity.mergeAssertions(lpfEntity0);
                   lpfEntity.mergeAttributes(lpfEntity0);
                  lpfEntity.entityType = (lpfEntity.entityType |  lpfEntity0.entityType);
                  lpfEntity.entityClass =  lpfEntity0.entityClass;      // Person, nonPerson etc.
                  
                  System.out.println("-- Total number of assertions for Entity " + lpfEntity.subject.getText() +
                        ":  " +   lpfEntity.getNumAssertions());
                  if (lpfEntity.pattr != null)
                     System.out.println (lpfEntity.pattr.toString());
                } 
            }
         return uniqueEntitys;
     }
 
 /**********************************************************************************************/   
    protected void assignReportingCategory(TreeMap  <TextAnchor, LPFEntity>uniqueEntityMap)
    {
        Iterator <TextAnchor> it = uniqueEntityMap.keySet().iterator();
        while (it.hasNext())
        {
            TextAnchor personAnchor  = it.next();
            // Check if it is a non-person
            LPFEntity lpfPerson = uniqueEntityMap.get(personAnchor);
             lpfPerson.personCategory = 0;
            if (lpfPerson.entityClass != LPFEntity.PERSON_ENTITY)
               continue;

            int entityType = lpfPerson.entityType;          // subject or object
            int personCategory  = 0;
            ArrayList< PredicateModel> predicates = lpfPerson.getAllPredicates();  
            for (int i = 0; i <predicates.size(); i++)
             {
                 PredicateModel predicate =predicates.get(i);
                 // set the person category (reporter.reported/unknown)
                int verbType = predicate.getLpfVerbCategory();
                // if used as a subject only of a reporting verb
                if (verbType == LPFVerbs.REPORTING_VERB  &&  entityType == NERConstants.CLAUSAL_SUBJECT)
                    personCategory  = personCategory | InferredPerson.REPORTER;
                
                // used as an object of a reporting verb
                else if (verbType == LPFVerbs.REPORTING_VERB  &&  
                    (entityType == NERConstants.CLAUSAL_OBJECT || entityType == NERConstants.CLAUSAL_SUBJ_OBJ))
                    personCategory = personCategory | InferredPerson.REPORTED_PERSON;
                    
                // ignore the object of a Reported_person verb, only use the subject
                else if (verbType == LPFVerbs.HEALTH_STATUS_VERB )
                {
                    if  (entityType == NERConstants.CLAUSAL_OBJECT) // || entityType == NERConstants.CLAUSAL_SUBJ_OBJ)
                                ;
                    else 
                        personCategory = personCategory | InferredPerson.REPORTED_PERSON;
                }
             }
            lpfPerson.personCategory = personCategory;
        }
        return; 
    }
  /**********************************************************************************************/   
      ArrayList  <InferredPerson> createInferredPersonList(
           TreeMap  <TextAnchor, LPFEntity> uniqueEntityMap,  
           TreeMap <TextAnchor, PersonAttributes>  personAttributeMap)
       {
            System.out.println(">>Message: " + lpfMessage.getContent().toString());
            
            ArrayList<InferredPerson> infPersonList = new ArrayList();
           Iterator <TextAnchor> it = uniqueEntityMap.keySet().iterator();
           while (it.hasNext())
           {
              TextAnchor personAnchor  = it.next();
               // Check if it is a non-person
               String personText = personAnchor.getText();
             /*  if (Utils.isInList(personText, NERConstants.NonPersonNouns))
               {
                   log.info("Ignoring  subject " + personText);
                   continue;
               }*/
                   
               LPFEntity lpfPerson = uniqueEntityMap.get(personAnchor);
               if( (lpfPerson.personCategory &InferredPerson.REPORTED_PERSON) == 0)
               {
                   System.out.println("--- ignoring Entity: " + lpfPerson.subject.getText());
                   continue;
               }
               // Check if the person is simply a reporter, or has reporting data
                ArrayList<InferredPerson>  infPersons = createInferredPersonRecord( lpfPerson, personAttributeMap);
                infPersonList.addAll(infPersons);
           }   
           
         // Sort according to best match (highest confidence), and
          // currently return only the top (bestmatch one)
            ArrayList<InferredPerson>  candidatePersons = new ArrayList();
             if (infPersonList.size() > 0)
             {
                sortPersonsByRank(infPersonList);
                candidatePersons.add(infPersonList.get(0));
             }
            return  candidatePersons;
       }
     
    /**********************************************************************************************/   
     protected  ArrayList<InferredPerson>  createInferredPersonRecord(LPFEntity lpfPerson,
         TreeMap <TextAnchor, PersonAttributes>  personAttributeMap)
     {
         // get the most relevant assertion as a subject
         ArrayList <PredicateModel>subjectVerbModels = lpfPerson.getPredicateModels();
         
         // also add the Verb models where this person is an object
           ArrayList <PredicateModel>objectVerbModels = lpfPerson.objectPredicates;
           ArrayList <PredicateModel> verbModels = new ArrayList();
           if (subjectVerbModels != null)
               verbModels.addAll(subjectVerbModels);
           if (objectVerbModels != null)
               verbModels.addAll(objectVerbModels);
           
        // now  select the appropriate verb for this lpfSubject in order of importance
        PredicateModel selectedVerb  = vbInfer.selectVerb(verbModels);
        int verbType = selectedVerb.lpfVerbCategory;
       
        ClausalAssertion assertion = lpfPerson.getAssertionForVerb(selectedVerb.verb);
        
        InferredPerson repPerson = null;
        ArrayList <InferredPerson> repPersons = new ArrayList();
        // if the lpfPerson is simply a subject and not  being reported, ignore it
        if  ( lpfPerson.entityClass == LPFEntity.PERSON_ENTITY  &&  verbType == LPFVerbs.REPORTING_VERB 
           && lpfPerson.entityType == CLAUSAL_SUBJECT && lpfPerson.isReporterSubject() )
        {
            log.info("Reporting Person " + lpfPerson.subject.getText() + " is ignored");
           //repPersons = getInfoFromReporter(lpfPerson, assertion, selectedVerb);
        }
         else
         {
            repPerson = createRecordFromInferredPerson(lpfPerson, assertion, selectedVerb);
            repPersons.add(repPerson);
         }
        return repPersons;
    }
   /*****************************************************************************************/
     // get the assertion for a given verb model  - by matching their clauses
    protected ClausalAssertion getAssertionForVerb(
            ArrayList<ClausalAssertion> assertions, PredicateModel verbModel)
    {
        Clause vclause = verbModel.verbClause;
        for (int i = 0; i < assertions.size(); i++)
        {
            if (assertions.get(i).clause.clauseHead.equals(vclause.clauseHead))
                return assertions.get(i);
        }
        return null;
    }
    
  
  /*****************************************************************************************/
     // determine the final status category for this verb, based upon the Verb model 
    // and the clause type etc.
    protected String getHealthStatusCategory( PredicateModel verbModel, int genre)
    {
          VerbAnchor verb = (VerbAnchor) verbModel.verb;
           String status = verb.getGovernorToken().text;       // use morphological root for test
           String morphStatus = verb.getGovernorToken().getRootWord();
           String negativeWord = verb.isNegative() ? verb.getNegativeWord() :  null;
           String adjective = "";
           boolean interrogative = false;
           // TBD: dealing with a question

          // If the adjective is really a status type word (e.g. alive, okay, etc., 
           // use that as the verb instead
          String[] adjectives = verb.getAdjectives();
           for (int i = 0; i < adjectives.length; i++)
           {
               if (vbInterp.inAdjectiveStatusList(adjectives[i]))
               {
                   status =  vbInfer.analyzeVerbsForHealthStatus(
                   verbModel, genre, negativeWord, adjectives,  interrogative);
                   break;
               }
           }
           String statusCategory  = "";
           if (verbModel.lpfVerbCategory == LPFVerbs.HEALTH_STATUS_VERB)
           {
               statusCategory = vbInfer.analyzeVerbsForHealthStatus(
                   verbModel, genre, negativeWord, adjectives,  interrogative);
           }
            if (verbModel.lpfVerbCategory == LPFVerbs.REPORTING_VERB)
           {
               statusCategory = vbInfer.analyzeVerbsForReporter(verbModel, 
                  genre,  negativeWord, adjectives);
           }

             // Map to external form
              String healthStatusCategory  = "";            
             if (statusCategory.length() > 0)
                 healthStatusCategory = PLLexicon.getHealthStatusType(statusCategory);
             return healthStatusCategory;
    }
   
      /**********************************************************************************************/         
     protected InferredPerson  createRecordFromInferredPerson(LPFEntity lpfPerson, 
                ClausalAssertion selectedAssertion, PredicateModel verbModel)     
       {
           InferredPerson person = new InferredPerson(InferredPerson.REPORTED_PERSON);
           person.person = lpfPerson.subject;
           
           boolean interrogative = false;
           // TBD: dealing with a question

           person.healthStatus = verbModel.healthStatusCondition;
           person.verbString =  verbModel.verb.getCoveringText(); //verbModel.modifier +" "  +verbModel.verb.getFullTextWithConjunct();
           
           // check for location in the following specific order
           ArrayList <TextAnchor> locations = lpfPerson.getDirectLocations();
           if (locations == null || locations.isEmpty())
               locations = lpfPerson.getSubjectLocations();
           if ( locations == null  || locations.isEmpty())
               locations = lpfPerson.getObjectLocations();
           person.locations = (locations != null && locations.size() > 0 ) ? locations : null;
           
           
           // check for other attributes provided through a PersonalAttribute record
           PersonAttributes pattr = lpfPerson.pattr;
           if (pattr != null)
           {
               if (pattr.name != null)      // get the full name
               {
                   TextAnchor nameAnchor = pattr.name;
                   if (corefMap.get(pattr.name) != null) 
                       nameAnchor = corefMap.get(pattr.name).corefAnchor;
                   person.person = (nameAnchor == null) ? pattr.name : nameAnchor;
               }
   
               if (pattr.location != null)
               {
                   person.locations = new ArrayList();
                   person.locations.add (pattr.location);
               }
               if (person.healthStatus  == null && pattr.statusWord != null)
                   person.healthStatus = pattr.statusWord.getText();
               
               if (person.age  == null && pattr.age != null)
                   person.age = pattr.age.getText();
               if (person.gender  == null)
                   person.gender = pattr.gender;
           }
         
          person.isNegative = verbModel.isNegative;
          SubjectEntity reporterSubj = getReporterForSubject(lpfPerson);
           if (reporterSubj != null)
           {
                person.reporter = reporterSubj.subject;
                System.out.println( ">>> Referring  Reporter for  " + person.person.getText() + 
                       " is :  " + person.reporter.getText() + " <<<");
           }
           else
           {
                  System.out.println( ">>> No  Reporter  found for for  " + person.person.getText() );
           }   
           int confidence = rankInferredPerson(person, lpfPerson, numMsgAssertions);
           person.confidenceRanking = confidence;
          log.info("**PERSON*****\n " +  person.toString());
           return person;
       }
   /********************************************************************************************/  
     // Get the reporter which has the given subject as a Reported Person (
   protected SubjectEntity getReporterForSubject(LPFEntity lpfPerson)
   {
         ArrayList <SubjectEntity> reporters = lpfPerson.reporters;
         for (int i = 0;  reporters != null && i < reporters.size(); i++)
         {
             SubjectEntity reporter = reporters.get(i);
             if (reporter.subject == null)                  // Referring subject not present (missing I...)
                 continue;
             String textStr =reporter.subject.getText().toLowerCase();
             if (textStr.contains(" name") || textStr.contains(" age ") || textStr.contains(" years"))
                 continue; 
             else
                 return reporter; 
         }    
         return null;
   }
   

     //---------------------------------------------------------------------------------------------------------------------//
      protected   LPFEntity  getReferredEntity(TextAnchor subject,  
        TreeMap <TextAnchor,  LPFEntity> uniqueEntityMap)
    {
       if  (uniqueEntityMap.size() == 0)
           return null;
       LPFEntity referredEntity = uniqueEntityMap.get(subject);
       if (referredEntity != null)
           return referredEntity;
       String curName = subject.getText();
       ArrayList<TextAnchor> subjectList = new ArrayList(uniqueEntityMap.keySet());
       for (int i = 0; i < subjectList.size(); i++)
       {
           String subjectName = subjectList.get(i).getText();
           if (NameResolver.isEquivalentName(curName, subjectName))
               return uniqueEntityMap.get(subjectList.get(i));
       }
       return null;
  }

   
   
     /* ---------------------------------------------------------------------------------------------------------
     protected  LPFPerson  fillReporterInfo(ClausalAssertion clauseInfo, int verbType)
     {
         LPFPerson lpfPerson = new LPFPerson(verbType);
         lpfPerson.person = clauseInfo.subject;
         lpfPerson.adjective = clauseInfo.subject.getAdjective();
         lpfPerson.verb = clauseInfo.verb;
         lpfPerson.verbString = clauseInfo.verb.getTextWithConjunct();
         
         lpfPerson.locations = getLocations(clauseInfo.locationList);
         lpfPerson.persons = clauseInfo.personList;
                  
         // go though lower level clauses and the same info
         lpfPerson.reported = (lpfPerson.reported == null) ? null :  clauseInfo.objectClause.subject;
         return lpfPerson;
     }
 /*--------------------------------------------------------------------------------------------------
          protected  LPFPerson  fillReportedPersonInfo(ClausalAssertion clauseInfo, int verbType)
     {
         LPFPerson lpfPerson = new LPFPerson(verbType);
         lpfPerson.person = clauseInfo.subject;
         lpfPerson.adjective = clauseInfo.subject.getAdjective();
         lpfPerson.verb = clauseInfo.verb;
         lpfPerson.verbString = clauseInfo.verb.getTextWithConjunct();
         
         lpfPerson.locations = clauseInfo.locations;
         return lpfPerson;
     }
*/
 
     /******************************************************************************************/  
   
/*  protected ArrayList<LPFPerson> mergeReporterReported(ArrayList<LPFPerson> persons)
  {
          ArrayList <LPFPerson> reportedPersonList = new ArrayList();
          ArrayList <LPFPerson> reporterList = new ArrayList();
         for (int i = 0; i < persons.size(); i++)
         {
             if (persons.get(i).type == LPFPerson.REPORTED_PERSON)
                 reportedPersonList.add(persons.get(i));
             else if (persons.get(i).type ==  LPFPerson.REPORTER || 
                            persons.get(i).type ==  LPFPerson.REPORTER_REPORTED )
                 reporterList.add(persons.get(i));
         } 
         
         // convert each Reporter information to Reported person information
         for (int i = 0; i < reporterList.size(); i++)
         {
             LPFPerson reporter =  
              TextAnchor reported = person.reported;

             }    
*/
    /**********************************************************************************************/
    // Scan the list for a matching subject
    // TBD: currently, it does not check the verb type to match person type 
    protected SubjectEntity  getLPFSubjectInList(Clause clause, int personType)
    {
        TextAnchor subject = clause.subject;
        if (subject == null)
            return null;            // clause has no subject
        
        SubjectEntity nextSubject  = null;
        Iterator <TextAnchor> it = lpfSubjectMap.keySet().iterator();
        while (it.hasNext())
        {
            TextAnchor anchor = it.next();
            nextSubject = lpfSubjectMap.get(anchor);
            if (nextSubject.subject.equals(subject))
                return nextSubject;
        }
        if (personType == InferredPerson.REPORTER)
            return null;
            
        // if there is no match go up one level in parent hierachy for REPORTED_PERSONS
        if (nextSubject == null)
            clause = clause.parentClause;
        if (clause == null)
            return null;
        else
            return getLPFSubjectInList(clause, personType);
    }
 /***************************************************************************************/
    // Compute the confidence  ranking of the Inferred person regarding its accuracy 
    protected int  rankInferredPerson(InferredPerson repPerson, LPFEntity reportedEntity,  int nAssertions)
    {
        PersonRanker ranker = new PersonRanker(repPerson);
        int rank =  ranker.rankPerson(reportedEntity, nAssertions);
        return rank;
    }
    
    // sort in place according to ranking 
    protected  void sortPersonsByRank(ArrayList <InferredPerson> repPersons)
    {
        if (repPersons == null || repPersons.size() <= 1)
            return;
        Collections.sort(repPersons);
    }

    /***************************************************************************************/        
    public ProcessedResults getProcessedResults()
    {
        return processedResults;
    }

   /********************************************************************************************/
   // update for missing fields for a reported person if it can be found in the corresponding
   // reporter information
    /********************************************************************************************/
 /*  protected boolean updateReportedPersonInfo(PLPersonInfo pinfo, PLPersonInfo rinfo)     
   {
       if (rinfo.type != PLPersonInfo.REPORTER && rinfo.type != PLPersonInfo.REPORTER_REPORTED)
           return false;            // no information from reporter
       
       boolean updated = false;
       if (pinfo.personName.length() == 0 && rinfo.reportedPerson.length() > 0)
       {
           pinfo.personName = rinfo.reportedPerson;
           updated = true;
       }
       if (pinfo.personLocation.length() == 0 && rinfo.reportedLocation.length() > 0)
       {
           pinfo.personLocation = rinfo.reportedLocation;
           updated = true;
       }
         if (pinfo.healthStatus.length() == 0 && rinfo.reportingStatus.length() > 0)
       {
           pinfo.healthStatus = rinfo.reportingStatus;
           updated = true;          
       }
       return updated;
   }     
*/
  
   /*--------------------------------------------------------------------------------------------------------------*/
}
